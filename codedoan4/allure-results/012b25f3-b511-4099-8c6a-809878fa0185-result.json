{"name": "test_dang_nhap_excel[hoangnguyet@gmail.com-1423Nguyet*-L\\u1ed7i: M\\u1eadt kh\\u1ea9u b\\u1ea1n nh\\u1eadp cho \\u0111\\u1ecba ch\\u1ec9 email hoangnguyet@gmail.com kh\\xf4ng \\u0111\\xfang. B\\u1ea1n qu\\xean m\\u1eadt kh\\u1ea9u?]", "status": "broken", "statusDetails": {"message": "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None)\", ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None))", "trace": "self = <urllib3.response.HTTPResponse object at 0x000001EE39C18D90>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n.venv\\Lib\\site-packages\\urllib3\\response.py:779: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv\\Lib\\site-packages\\urllib3\\response.py:904: in _raw_read\n    data = self._fp_read(amt, read1=read1) if not fp_closed else b\"\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\urllib3\\response.py:887: in _fp_read\n    return self._fp.read(amt) if amt is not None else self._fp.read()\n           ^^^^^^^^^^^^^^^^^^\nC:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\http\\client.py:479: in read\n    s = self.fp.read(amt)\n        ^^^^^^^^^^^^^^^^^\nC:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\socket.py:719: in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\ssl.py:1304: in recv_into\n    return self.read(nbytes, buffer)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=2, type=1, proto=0>, len = 1302, buffer = <memory at 0x000001EE39DDDD80>\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n    \n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Read on closed or unwrapped SSL socket.\")\n        try:\n            if buffer is not None:\n>               return self._sslobj.read(len, buffer)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE               ConnectionAbortedError: [WinError 10053] An established connection was aborted by the software in your host machine\n\nC:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\ssl.py:1138: ConnectionAbortedError\n\nThe above exception was the direct cause of the following exception:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n>               yield from self.raw.stream(chunk_size, decode_content=True)\n\n.venv\\Lib\\site-packages\\requests\\models.py:820: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv\\Lib\\site-packages\\urllib3\\response.py:1091: in stream\n    data = self.read(amt=amt, decode_content=decode_content)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\urllib3\\response.py:980: in read\n    data = self._raw_read(amt)\n           ^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\urllib3\\response.py:903: in _raw_read\n    with self._error_catcher():\n         ^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\contextlib.py:162: in __exit__\n    self.gen.throw(value)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x000001EE39C18D90>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except IncompleteRead as e:\n                if (\n                    e.expected is not None\n                    and e.partial is not None\n                    and e.expected == -e.partial\n                ):\n                    arg = \"Response may not contain content.\"\n                else:\n                    arg = f\"Connection broken: {e!r}\"\n                raise ProtocolError(arg, e) from e\n    \n            except (HTTPException, OSError) as e:\n>               raise ProtocolError(f\"Connection broken: {e!r}\", e) from e\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None)\", ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None))\n\n.venv\\Lib\\site-packages\\urllib3\\response.py:806: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"function\")\n    def cau_hinh():\n        \"\"\"Khởi tạo Chrome driver + trả về URL, đồng thời dùng cho logging & chụp ảnh.\"\"\"\n        chrome_options = Options()\n        chrome_options.add_argument(\"--start-maximized\")\n    \n>       service = Service(ChromeDriverManager().install())\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\conftest.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv\\Lib\\site-packages\\webdriver_manager\\chrome.py:40: in install\n    driver_path = self._get_driver_binary_path(self.driver)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\webdriver_manager\\core\\manager.py:40: in _get_driver_binary_path\n    file = self._download_manager.download_file(driver.get_driver_download_url(os_type))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\webdriver_manager\\core\\download_manager.py:32: in download_file\n    return File(response, file_name)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\webdriver_manager\\core\\file_manager.py:12: in __init__\n    self.content = stream.content\n                   ^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\requests\\models.py:902: in content\n    self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n                yield from self.raw.stream(chunk_size, decode_content=True)\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None)\", ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None))\n\n.venv\\Lib\\site-packages\\requests\\models.py:822: ChunkedEncodingError"}, "attachments": [{"name": "log", "source": "95f6764e-40e5-481d-a6f3-10dd3a5262fe-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "email", "value": "'hoangnguyet@gmail.com'"}, {"name": "matkhau", "value": "'1423Nguyet*'"}, {"name": "ketquamongdoi", "value": "'Lỗi: Mật khẩu bạn nhập cho địa chỉ email hoangnguyet@gmail.com không đúng. Bạn quên mật khẩu?'"}], "start": 1760576119409, "stop": 1760576119409, "uuid": "542f2786-faab-43b5-a4da-6dbc324234cd", "historyId": "5c994cff99d910fe40e93dff828a8e51", "testCaseId": "0c77a1d4b017f09bf3c4c272180f069c", "fullName": "tests.test_login_xlsx#test_dang_nhap_excel", "labels": [{"name": "tag", "value": "excel"}, {"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_login_xlsx"}, {"name": "host", "value": "DESKTOP-V702B1G"}, {"name": "thread", "value": "28924-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_login_xlsx"}], "titlePath": ["tests", "test_login_xlsx.py"]}